

#include "connection.h"
#include "ip.h"
#include "packet.h"
#include "socket_helper.h"
#include <cassert>
#include <cstddef>
#include <cstring>
#include <future>
#include <iostream>

template < typename IP_TYPE >
spyke::communication::connection::Connection< IP_TYPE > connect_with_server( const IP_TYPE& server_ip ) { return spyke::communication::connection::Connection< IP_TYPE >::connect_to( server_ip ); }

void arbitrary_communication_check() {

  std::cout << "\n*** ARBITRARY COMMUNICATION TEST ***\n" << std::endl;

  char ip_v6_addr[] = "::1"; short port = 8050;
  
  {
  
    std::cout << "\tSending arbitrary data check: ";
    spyke::communication::connection::IP_V4 ip_v4 = spyke::communication::connection::IP_V4( 0x7F000001, port ++ );
    spyke::communication::connection::IP_V6 ip_v6 = spyke::communication::connection::IP_V6::from_hex( ip_v6_addr, port ++ );

    spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 > server_ip_v4 =
      std::move( spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 >::create_server( ip_v4 ) );

    spyke::communication::connection::Connection< spyke::communication::connection::IP_V6 > server_ip_v6 =
      std::move( spyke::communication::connection::Connection< spyke::communication::connection::IP_V6 >::create_server( ip_v6 ) );

    assert( server_connection_ip_v4.is_connected() ); assert( server_connection_ip_v6.is_connected() ); // true

    std::future< spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 > > future_client_ip_v4 =
      std::async( std::launch::async, connect_with_server< spyke::communication::connection::IP_V4 >, ip_v4 );

    std::future< spyke::communication::connection::Connection< spyke::communication::connection::IP_V6 > > future_client_ip_v6 =
      std::async( std::launch::async, connect_with_server< spyke::communication::connection::IP_V6 >, ip_v6 );

    spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 > server_client_connection_ip_v4;

      spyke::communication::connection::accept_connection_request( server_connection_ip_v4.get_socket_id() );

    spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 > client_connection_ip_v4 = std::move( future_client_ip_v4.get() );
    spyke::communication::connection::Connection< spyke::communication::connection::IP_V6 > client_connection_ip_v6 = std::move( future_client_ip_v6.get() );

    assert( client_connection_ip_v4.is_connected() ); assert( client_connection_ip_v6.is_connected() ); // true

    unsigned char protocol_id = 0; size_t data_size = sizeof( "Testing with random data!!" );
    unsigned char* data = new unsigned char[ data_size ]; std::memcpy( data, "Testing with random data!!", data_size );

    // spyke::communication::communication_protocols::Packet packet = 
      // spyke::communication::communication_protocols::Packet( protocol_id, data, data_size );
    // assert( packet.is_valid() ); // true
    
    // const bool sts_send_packet_client_ip_v4 = packet.send( client_connection_ip_v4.get_socket_id() );
    // assert( sts_send_packet_client_ip_v4 ); // true

    // const bool sts_send_packet_client_ip_v6 = packet.send( client_connection_ip_v6.get_socket_id() );
    // assert( sts_send_packet_client_ip_v6 ); // true
    
    // const spyke::communication::communication_protocols::Packet packet_received_ip_v4 = spyke::communication::communication_protocols::Packet::receive_packet( client_connection_ip_v4.get_socket_id() );
    // const spyke::communication::communication_protocols::Packet packet_received_ip_v6 = spyke::communication::communication_protocols::Packet::receive_packet( client_connection_ip_v6.get_socket_id() );

    // assert( packet_received_ip_v4.is_valid() ); // true
    // assert( packet_received_ip_v6.is_valid() ); // true

    std::cout << "Pass" << std::endl;

  }

}


// Forward
spyke::communication::connection::Connection< spyke::communication::connection::IP_V4 > connect_with_server( const spyke::communication::connection::IP_V4& );
spyke::communication::connection::Connection< spyke::communication::connection::IP_V6 > connect_with_server( const spyke::communication::connection::IP_V6& );
